"""Document service for business logic operations.

Handles document validation, processing, and business rules.
"""
from typing import Dict, Any, Optional
from ...core.service import BaseService
from ...core.entities import Document
from .repository import DocumentRepository


class DocumentService(BaseService[Document]):
    """Service for document business logic."""

    def __init__(self):
        super().__init__(DocumentRepository())

    def _validate_entity(self, entity: Document) -> None:
        """Validate document before saving."""
        self._validate_metadata(entity.metadata)

    def _create_entity_from_data(self, entity_id: str, data: Dict[str, Any]) -> Document:
        """Create document from data."""
        content = data.get('content', '')
        if not content or not content.strip():
            raise ValueError("Document content cannot be empty")

        # Calculate content hash
        content_hash = self.repository.calculate_content_hash(content)

        # Check for duplicates
        existing = self.repository.get_by_content_hash(content_hash)
        if existing:
            return existing

        return Document(
            id=entity_id,
            content=content,
            content_hash=content_hash,
            metadata=data.get('metadata', {}),
            correlation_id=data.get('correlation_id')
        )

    def create_document(self, content: str, metadata: Optional[Dict[str, Any]] = None,
                       document_id: Optional[str] = None, correlation_id: Optional[str] = None) -> Document:
        """Create a new document with validation."""
        data = {
            'content': content,
            'metadata': metadata or {},
            'correlation_id': correlation_id
        }
        return self.create_entity(data, document_id)

    def update_metadata(self, document_id: str, metadata: Dict[str, Any]) -> None:
        """Update document metadata."""
        self.update_entity(document_id, {'metadata': metadata})

    def search_documents(self, query: str, limit: int = 50) -> Dict[str, Any]:
        """Search documents by content."""
        if not query or not query.strip():
            raise ValueError("Search query cannot be empty")

        results = self.repository.search_documents(query.strip(), limit)

        return {
            "items": results,
            "total": len(results),
            "query": query,
            "limit": limit
        }

    def get_quality_metrics(self, limit: int = 1000) -> Dict[str, Any]:
        """Get document quality metrics."""
        metrics = self.repository.get_quality_metrics(limit)

        # Aggregate quality statistics
        total = len(metrics)
        stale_count = sum(1 for m in metrics if 'stale' in m.get('flags', []))
        redundant_count = sum(1 for m in metrics if 'redundant' in m.get('flags', []))

        return {
            "items": metrics,
            "total": total,
            "stale_count": stale_count,
            "redundant_count": redundant_count,
            "stale_percentage": (stale_count / total * 100) if total > 0 else 0,
            "redundant_percentage": (redundant_count / total * 100) if total > 0 else 0
        }

    def get_related_documents(self, correlation_id: str) -> list[Dict[str, Any]]:
        """Get documents by correlation ID."""
        return self.repository.get_documents_by_correlation_id(correlation_id)

    def list_documents(self, limit: int = 50, offset: int = 0) -> Dict[str, Any]:
        """List documents with pagination."""
        return self.list_entities(limit, offset)

    def get_documents_by_prompt_id(self, prompt_id: str) -> List[Document]:
        """Get all documents generated by a specific prompt."""
        return self.repository.get_by_metadata_field("original_prompt_id", prompt_id)

    def get_prompts_with_documents(self) -> Dict[str, List[Document]]:
        """Get all prompt IDs that have generated documents, with their documents."""
        documents = self.repository.get_by_metadata_field_exists("original_prompt_id")
        prompt_docs = {}
        for doc in documents:
            prompt_id = doc.metadata.get("original_prompt_id")
            if prompt_id:
                if prompt_id not in prompt_docs:
                    prompt_docs[prompt_id] = []
                prompt_docs[prompt_id].append(doc)
        return prompt_docs

    def _validate_metadata(self, metadata: Dict[str, Any]) -> None:
        """Validate document metadata."""
        if not isinstance(metadata, dict):
            raise ValueError("Metadata must be a dictionary")

        # Check for reserved keys
        reserved_keys = {'id', 'content', 'content_hash', 'created_at', 'updated_at'}
        for key in reserved_keys:
            if key in metadata:
                raise ValueError(f"Metadata cannot contain reserved key: {key}")

        # Validate specific metadata fields if present
        if 'views' in metadata and not isinstance(metadata['views'], int):
            raise ValueError("Views must be an integer")

        if 'unique_views' in metadata and not isinstance(metadata['unique_views'], int):
            raise ValueError("Unique views must be an integer")

        if 'watchers' in metadata and not isinstance(metadata['watchers'], int):
            raise ValueError("Watchers must be an integer")
